---
title: "Intro to Tidyverse Part 1"
author: "Jessica Cooperstone"
date: "9/16/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

**What will we go over today**

-   What is the tidyverse and why would I want to use it?
-   Understanding how to use ["the pipe"](https://style.tidyverse.org/pipes.html) `%>%`
-   Using [`filter()`](https://dplyr.tidyverse.org/reference/filter.html) - picks observations (i.e., rows) based on their values
-   Using [`select()`](https://dplyr.tidyverse.org/reference/select.html) - picks variables (i.e., columns) based on their names

## 1 - What is the tidyverse, and how do I use it?

The [tidyverse](https://www.tidyverse.org/) is a collection of R packages that are designed for data science. You can certainly use R without using the tidyverse, but it has many packages that I think will make your life a lot easier. The popular package [`ggplot2`](https://ggplot2.tidyverse.org/index.html) is a part of the core tidyverse, which we have talked about in previous Code Clubs ([intro](/codeclub/04_ggplot2), [intro2](/codeclub/05_ggplot-round-2), [maps](/codeclub/11_ggplot-maps), and [ggplotly](/codeclub/15_plotly)), and will talk about in future sessions as well.

Before we talk more about the tidyverse, let's download it.

```{r, eval = FALSE}
install.packages("tidyverse")
```

To use any of the packages within the tidyverse, we need to call them up using `library()`.

```{r}
library(tidyverse)
```

Let's look at this message, we can see that there are eight "attaching packages" as part of the ["core"](https://www.tidyverse.org/packages/) set of tidyverse.  

We see that there are some conflicts, for example, there is a function called `filter()` (which we will talk about today) that is part of `dplyr` (a tidyverse package) that is masking another function called `filter()` within the `stats` package (which loads with base R).  Now this is fine for us right now, so there is nothing to do, but it is a good habit to get into reading (and not ignoring) any warnings or messages that R gives you.  (It is trying to help!)

Note the double colon operator `::` which indicates a function from a particular package.  So when you see `stats::filter()`, that indicates the function `filter()` within the package `stats`.

Below is a quick description of what each package is used for.

- [`dplyr`](https://dplyr.tidyverse.org/): for data manipulation
- [`ggplot2`](https://ggplot2.tidyverse.org/): a "grammar of graphics" for creating beautiful plots
- [`forcats`](https://forcats.tidyverse.org/): for handling categorical variables (i.e., factors) (meow!)
- [`tibble`](https://tibble.tidyverse.org/): using tibbles as modern/better dataframes
- [`readr`](https://readr.tidyverse.org/): for reading in rectangular data (i.e., Excel-style formatting)
- [`stringr`](https://stringr.tidyverse.org/): handling strings (i.e., text or stuff in quotes)
- [`tidyr`](https://tidyr.tidyverse.org/): to make "tidy data"
- [`purrr`](https://purrr.tidyverse.org/): for enhancing functional programming (also meow!)

If you're not understanding what some of this means, that's totally fine, its not important that you do right now.

There are more tidyverse packages outside of these core eight, and you can see what they are below.

```{r}
tidyverse_packages()
```

**tl;dr** Tidyverse has a lot of packages that make data analysis easier.  None of them are 'required' to do data analysis, but many tidyverse approaches you'll find easier than using base R.  

You can find [here](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html) some examples of comparing tidyverse and base R syntax.

------------------------------------------------------------------------

## Breakout session 1 - install tidyverse

In your breakout sessions, make sure that you each have the tidyverse installed and loaded.  

```{r, eval = FALSE}
install.packages("tidyverse")
install.packages("dplyr") # this is the only one of the 8 tidyverse packages we will use today
```

```{r}
library(tidyverse)
```

Occasionally we see people who are having tidyverse install issues, if this happens to you, please read the warning that R gives you, you may need to download an additional package to get it to work.  If you have trouble, first try restarting your R session and see if that helps, or reach out to one of the organizers or one of your fellow codeclubbers.  

------------------------------------------------------------------------

## 2 - Using the pipe `%>%`

The pipe operator `%>%` is a tool that is used for expressing a series of operations.  It comes from the [`magrittr`](https://cran.r-project.org/web/packages/magrittr/index.html) package, and is loaded automatically when you load the tidyverse.  

The purpose of the pipe is to allow you to take the output of one operation and have it be the starting material of the next step.  It also (hopefully) makes your code easier to read and interpret.  

**Let's get set up and grab some data so that we have some material to work with**

We are going to use a package called [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/) which has some fun ðŸ§ data for us to play with.  To get this data, we need to install the `palmerpenguins` package.

```{r, eval = FALSE}
install.packages(palmerpenguins)
```

Then, to use the package, we need to use the function `library()` to call the package up in R.
```{r}
library(palmerpenguins)
```

The data we want to use is called `penguins`.

```{r}
# look at the first 6 rows, all columns
head(penguins)

# check the structure of penguins_data
glimpse(penguins)
```

Okay now we have a sense of what the `penguins` dataset is.

We can use the pipe to send `penguins` forward through a series of steps.  For example, we can use the function `count()` to figure out how many of each penguin `species` there are in our dataset.

```{r}
penguins %>% # take penguins_data
  count(species) # count how many of each species there is
```

You could alternatively write your code like this.  In the `count()` function, the first argument is the dataset, and the next argument is what you want to be counted.  You can always learn more about the functions by using `?count()` or googling for the documentation.

```{r}
count(penguins, species)
```

You can see you get the same thing.  The benefit of the pipe is readability, and also the ability to pipe many things together (which we are not doing with `count()`).

I am going to show you an example of a place I think the pipe really shines, don't worry if you don't understand all the syntax, I just want you to see how the pipe can be used.

```{r}
penguins %>%
  drop_na() %>% # drop missing values listed as NA
  group_by(species) %>% # group by species
  summarize(mean_mass = mean(body_mass_g)) # summarize mass into new column called 
```

We are going to continue to use the pipe `%>%` as we practice with some new `dplyr` functions.

------------------------------------------------------------------------

## 3 - Using `select()`

It has been estimated that the process of getting your data into the appropriate formats takes about 80% of the total time of analysis.  I find that getting data into a format that enables analysis often trips people up more than doing the actual analysis.  The tidyverse packages `dplyr` has a number of functions that help in data wrangling.

The first one we will talk about is `select()`.  Tidyverse is nice in that the functions are very descritpive and intuitive as to what they do: `select()` allows you to pick certain columns to be included in your data frame.  

Let's try out both the `%>%` and `select()`.  Let's make a new dataframe from `penguins` that contains only the variables `species`, `island` and `sex`.

```{r}
penguins_only_factors <- penguins %>%
  select(species, island, sex)
```

Did it work?
```{r}
head(penguins_only_factors)
```

Let's check the dimensions of each dataframe to make sure we have what we would expect
```{r}
# what are the dimensions of penguins?
dim(penguins)

# what are the dimensions of penguins_only_factors?
dim(penguins_only_factors)
```

The output is ordered rows (first number) by columns (second number).  Our output makes sense - we haven't removed any observation (i.e., rows), we have only selected some of the columns that we want to work with.

What if we want to pick just the first three columns?  We can do that too.
```{r}
str(penguins) # what are those first three columns?

penguins %>%
  select(species:bill_length_mm) %>% # pick columns species through bill_length_mm
  head() # you can add head() as part of your pipe!
```

Note, in the above chunk, this new dataframe is not being saved because we have not assigned it to anything.

You could use slightly different syntax to get the same thing using an indexing approach.
```{r}
penguins %>%
  select(1:3) %>% # pick columns one through three
  head()
```

There is also convenient shorthand for indicating what you *don't* want (instead of what you do).
```{r}
penguins %>%
  select(-year) %>% # all the columns except year
  head()
```

Embedded within `select()` is the column order - you change use the order you denote to change the order of your columns.
```{r}
penguins %>%
  select(bill_length_mm, island, flipper_length_mm) %>%
  head()
```

------------------------------------------------------------------------

## 4 - Using `filter()`

[`filter()`](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter) allows you to pick certain observations (i.e, rows) based on their values to be included in your data frame.  Let's see it in action.

We will select only the penguins that are the `species` "Chinstrap"
```{r}
penguins_chinstrap <- penguins %>%
  filter(species == "Chinstrap") # note the double equals

# let's check that it worked
penguins_chinstrap %>%
  count(species)
```
We can also check to see if we got what we would expect by looking at the dimensions of both `penguins` and `penguins_chinstrap`.
```{r}
dim(penguins)
dim(penguins_chinstrap)
```

Great, you can see we have kept all of the columns (denoted by the second number 8), but trimmed down or rows/observations to only the Chinstrap penguins.

You can use `filter()` in other useful ways too.  Let's make a new dataframe that has only the penguins that are over 5000 g.
```{r}
big_penguins <- penguins %>%
  filter(body_mass_g > 5000)

# did it work?
big_penguins %>%
  select(body_mass_g) %>%
  range()

# another faster non-tidyverse way to do this
range(big_penguins$body_mass_g)
```

You can start stacking qualifiers to get the exact penguins you want.  Let's say we are only interested in penguins that are female and on the island Dream.
```{r}
penguins %>%
  filter(sex == "female" & island == "Dream") 
```
There are lots of useful `filter()` functions like:

- `==`: exactly equals to
- `â‰¥`: greater than or equals to
- `â‰¤`: less than or equals to
- `&`: and
- `|`: or
- `!=`: not equal to
- `!x`: not x
- `is.na()`: is NA (i.e. missing data)

There is a longer list of helpful `select()` features [here](https://dplyr.tidyverse.org/reference/select.html).

**tl;dr, `select()` picks columns/variables and `filter()` picks rows/observations.**

## Breakout session 2 - pipe, filter, select

### Exercise 1

Make a new dataframe called `penguins_new` that includes only the columns with numeric or integer data.

```{r}
glimpse(penguins)

penguins_new <- penguins %>%
  select(bill_length_mm:body_mass_g, year)

# check to see if it worked
head(penguins_new)
```

Getting fancy with some more advanced options
```{r}
# this works too
penguins_new2 <- penguins %>%
  select(ends_with("mm"), body_mass_g, year)

# this works three
penguins_new3 <- penguins %>%
  select(where(is.numeric) | where(is.integer))

# are they all the same?
all.equal(penguins_new2, penguins_new3)
```

----

### Exercise 2

Make a new dataframe called `penguins_adelie_female` that includes only the female penguins that are of the `species` Adelie.

```{r}
penguins_adelie <- penguins %>%
  filter(species == "Adelie" & sex == "female")

# check to see if it worked
penguins_adelie %>%
  count(species, sex)
```

----

### Exercise 3

Make a new dataframe called `penguins_dream_or_2007` that includes only the penguins on the island dream, or from the year 2007.  Then make sure the dataframe only contains those variables you have filtered on.
```{r}
penguins_dream_or_2007 <- penguins %>%
  filter(island == "Dream" | year == "2007") %>%
  select(island, year)

head(penguins_dream_or_2007)

# did it work?
penguins_dream_or_2007 %>%
  count(island, year)
```

----

## Further reading

There are many good (free) references for the tidyverse, including the book [R for Data Science](https://r4ds.had.co.nz/) by Hadley Wickham and Garrett Grolemund.

The package [`dplyr`](https://dplyr.tidyverse.org/), as part of the [`tidyverse`](https://www.rdocumentation.org/packages/tidyverse/versions/1.3.0) has a number of very helpful functions that will help you get your data into a format suitable for your analysis.

RStudio makes very useful [cheatsheets](https://www.rstudio.com/resources/cheatsheets/), including ones on tidyverse packages like `dplyr`, `ggplot2`, and others.

