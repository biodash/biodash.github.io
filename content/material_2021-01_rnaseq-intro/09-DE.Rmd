---
title: "Differential expression (DE) analysis <br> with DESeq2"
author: "Jelmer Poelstra"
date: "3/26/2021"
output:
  html_document:
    code_download: true
    toc_depth: 3
    toc: true
    toc_float: true
    theme: cerulean
    highlight: tango
    anchor_sections: true
    css: html_page.css
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo=TRUE, eval=TRUE, cache=TRUE,
  warning=FALSE, message=FALSE,
  class.source = 'r_code',
  class.output = 'r_output',
  class.warning = 'r_warning',
  class.message = 'r_warning',
  class.error = 'r_error'
  )
```

<br> <br>

----

## Getting set up

### Start an RStudio session at OSC

<details><summary>Show instructions</summary>

- Login to OSC at <https://ondemand.osc.edu>.

- Click on `Interactive Apps` (top bar) > `RStudio Server (Owens and Pitzer)`

<p align="center">
<img src=img/apps.png width="500">
</p>

- Fill out the form as shown [here](slides/03-OSC-slides.html#rstudio_server_job).

- Now, you should see a box like this:

<p align="center">
<img src=img/osc_queued.png width="700">
</p>

- Your job should start running pretty soon, and when it's ready the box should look like this: 

<p align="center">
<img src=img/osc_running.png width="700">
</p>

- Click `Connect to RStudio Server` at the bottom of the box, and an RStudio Server instance will open. You're ready to go!

</details>

### Create an RStudio Project

<details><summary>Show instructions</summary>

```{r, eval=FALSE}
basedir <- '/fs/project/PAS0471/teach/misc/2021-02_rnaseq/'

# Get your user name (by running a shell command via the `system()` function:
me <- system("echo $USER", intern = TRUE)

# Build the path to the target dir:
proj_dir <- file.path(basedir, me)

# Create the Project:
library(usethis)
create_project(path = proj_dir)
```

Now, RStudio will reload with the newly created Project open.

If you get the pop-up below, click `Don't Save` (do this whenever you get that pop-up):

<p align="center">
<img src=img/rdata-popup.png width="350">
</p>

</details>

### Copy the count data and the metadata files

Go the `Terminal` tab next to the R `Console` in the bottom left of the RStudio
window:

```{sh, eval=FALSE}
cd /fs/project/PAS0471/teach/misc/2021-02_rnaseq/$USER

cp ../master/data/meta/metadata.txt data/meta
cp ../master/results/count/gene_counts_all.txt results/count
```

### Load the necessary packages

```{r, warning=FALSE, message=FALSE}
if(! 'pacman' %in% installed.packages()) install.packages('pacman')

packages <- c('DESeq2',          # Differential expression analysis
              'tidyverse',       # Misc. data manipulation and plotting
              'here',            # Managing file paths
              'pheatmap')        # Heatmap plot
pacman::p_load(char = packages)

theme_set(theme_bw())  # Set ggplot theme
```

### Input and output dirs and files

```{r, eval=TRUE, echo=FALSE}
count_table_file <- "results/count/gene_counts_all.txt"
metadata_file <- "data/meta/metadata.txt"

outdir <- "results/DE/"
plotdir <- "results/DE/fig/"
```

Input files:

- **Gene counts table** -- the file exactly as it was written by *featureCounts*.
  
- **Metadata table** -- so we can group our samples and make comparisons between
  these groups.

```{r, eval=FALSE}
count_table_file <- here("results/count/gene_counts_all.txt")
metadata_file <- here("data/meta/metadata.txt")
```

Output directories -- and we create them if they don't already exist:

```{r}
outdir <- here("results/DE/")
plotdir <- here("results/DE/fig/")

if (!dir.exists(plotdir)) dir.create(plotdir, recursive = TRUE)
if (!dir.exists(plotdir)) dir.create(plotdir, recursive = TRUE)
```

### Load input data

Load the count table from *featureCounts*:

```{r, eval=TRUE}
raw_counts <- read.table(count_table_file,
                         sep = "\t", header = TRUE, skip = 1)
```

Load the metadata information:

```{r}
metadata <- read.table(metadata_file, header = TRUE)

head(metadata)
```

<br>

----

## Prepare the data

Change the column names, which are very long:

```{r}
colnames(raw_counts)[7:8]
```

```{r}
my_regex <- ".+PonceM_(.+)_V1N.+"
colnames(raw_counts) <- sub(my_regex, "\\1", colnames(raw_counts))

colnames(raw_counts)
```

Besides the counts, there are columns with metadata for each gene:

```{r}
raw_counts[1:5, 1:8]
```

Let's remove those:

```{r}
counts <- raw_counts[, 7:ncol(raw_counts)]
rownames(counts) <- raw_counts$Geneid
```

### Replicate samples

In this table, there are two separate entries for each sample:
each library was sequenced on two lanes.
Recall that in our workflow, we had merged these FASTQ files prior to mapping,
but here we are using the table based on the full dataset produced by Matthew.

So, we will go ahead and merge these replicates now, by simply summing the counts:

```{r}
counts.t <- t(counts)
rownames(counts.t) <- names(raw_counts)[7:36]
sums <- rowsum(counts.t, group = rownames(counts.t))
counts <- t(sums)
```

(Alternatively, one could use the specialized function
`DESeq2::collapseReplicates()` for this.)

### Check sample IDs

For differential expression analysis, we will be using the popular**DESeq2**
R/Bioconductor package
([paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8),
[website](https://bioconductor.org/packages/release/bioc/html/DESeq2.html)).

We will load both the count table and the metadata into *DESeq2*.
When doing so, *DESeq2* assumes that sample IDs in both tables match and 
are provided in the same order. Let's make sure this is indeed the case.

Sort both data frames alphabetically:

```{r}
metadata <- metadata[order(metadata$SampleID), ]
counts <- counts[, order(colnames(counts))]
```

Check if names are the same:

```{r}
metadata$SampleID

colnames(counts)

matching_names <- identical(metadata$SampleID, colnames(counts))
matching_names
if(matching_names == FALSE) stop("Sample ID in metadata and count matrix do not match!")
```

### Create the DESeq2 object

We will create the DESeq2 object using the function `DESeqDataSetFromMatrix()`,
which we will provide with three pieces of information:

- The count data with argument `countData`.
- The metadata with argument `colData`.
- The model design for the DE analysis -- argument `design`.  
  For now, we will specify `~1`, which means "no design" --
  we will change this before the actual DE analysis.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~ 1)
```

<br>

----

## Explore the count data

What are number of rows and columns of the count matrix?

```{r}
dim(counts)
```

How many genes have non-zero counts?

```{r}
dim(counts[rowSums(counts) > 0, ])

```

How many genes have total counts of at least 10?

```{r}
dim(counts[rowSums(counts) >= 10, ])
```

### Histogram of gene counts

Let's plot a histogram of gene counts:

```{r}
theme_set(theme_bw())

summed_gene_counts <- data.frame(gene_count = rowSums(counts)) %>%
  rownames_to_column('gene_id')

ggplot(data = summed_gene_counts) +
  geom_histogram(aes(x = gene_count), binwidth = 10000) +
  scale_y_log10(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0,0))
```

Zoom in a bit:

```{r}
ggplot(data = summed_gene_counts) +
  geom_histogram(aes(x = gene_count), binwidth = 1000) +
  scale_y_log10(expand = c(0, 0)) +
  scale_x_continuous(limits = c(0, 200000), expand = c(0,0)) +
  theme(plot.margin = margin(0.5, 0.7, 0.5, 0.5, "cm"))
```

How are counts distributed across samples?

```{r}
apply(counts, 2, sum)
```

<br>

----

## Principal Component Analysis (PCA) 

### Run the PCA and prepare for plotting

First, we normalize the count data to have even sampling across samples
(with respect to library size) and approximately even variance:

```{r}
vsd <- varianceStabilizingTransformation(dds, blind = TRUE)
```

Next, we run the PCA and retrieve the data to plot with *ggplot2*:

```{r}
pcaData <- plotPCA(vsd,
                   ntop = 500,
                   intgroup = c("AMF", "Treatment"),
                   returnData = TRUE)
```

We extract the percentage of variance explained by different principal components,
so we can later add this information to the plot:

```{r}
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

We create a plot title with some italic text using the `expression()` function: 

```{r}
plot_title <- expression("PCA of " * italic(Glycine ~ max) * " transcript count data")
```

### Plot the PCA results

```{r}
ggplot(pcaData,
       aes(PC1, PC2, color = AMF, shape = Treatment)) +
  geom_point(size = 6) +
  xlab(paste0("PC1: ", percentVar[1], "% of variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% of variance")) +
  ggtitle(plot_title)
```

### Plot again -- with sample names

```{r}
library(ggrepel)

pca_plot2 <- ggplot(pcaData,
              aes(PC1, PC2, color = AMF, shape = Treatment)) +
  geom_point(size = 3) +
  geom_label_repel(aes(label = name)) +
  xlab(paste0("PC1: ", percentVar[1], "% of variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% of variance")) +
  ggtitle(plot_title)

print(pca_plot2)
```

<br>

----

## DE analysis -- full dataset

The design has two factors: `AMF` and `Treatment`.
Rather than fit a multivariate model, we can start by merging the two into a
single factor called `group`, and fit a univariate model with this factor.

```{r}
dds$group <- factor(paste(dds$AMF, dds$Treatment, sep = "_"))
table(dds$group)
```

We will set the "reference" level of the factor to be the double negative control
(empty substrate, no Agrobacteria):

```{r}
dds$group <- relevel(dds$group, ref = "control_mock")
dds$group
```

Set the analysis design:

```{r}
design(dds) <- formula(~ group)
```

Perform the differential expression analysis:

```{r}
dds <- DESeq(dds)
```

The `DESeq()` function above performs three steps consecutively,
which could also be called separately
(which could be useful if you'd want to be able to change more defaults):
  
  - `estimateSizeFactors()` -- "Normalization" by library size.
    Note that *DESeq2* doesnâ€™t actually normalize the counts,
    it uses raw counts and includes the size factors in the modeling. 
  
  - `estimateDispersions()` -- Estimate gene-wise dispersions.
  
  - `nbinomWaldTest(ddsObj)` -- Fit the negative Binomial GLM and calculate
    Wald statistics.

### The results table

```{r}
results(dds)
```

By default, the results table prints statistics comparing the last level of the
factor with the first level: that is, log-fold change and p-values describe
differences between these two levels specifically.
However, we can easily extract equivalent statistics for any pairwise comparison
among our factor levels, which we will see later.

For now, we will explore the different columns in this table:

- The `baseMean` column contains the mean expression level across all samples.

- The `log2FoldChange` column contains the log2-fold change of gene counts
  between the compared levels, that is, it represents the *effect size*.
  A log2-fold change of 1 indicates that the expression in the reference level
  is 2 times lower than that of the other level, a log2-fold change of 2 indicates
  a four-fold difference, a log2-fold change of 3 indicates an eight-fold difference,
  and so on. Similarly, negative log2-fold change values indicate an change
  in gene counts in the other direction.
  
- The `lfcSE` column indicates the uncertainty in terms of the standard error
  (SE) of the log2-fold change estimate.
  
- The `stat` column indicates the value for the Wald test's test statistic.

- The `pvalue` column reported the *uncorrected* p-value from the Wald test.

- Because we are testing significance for *many* genes,
  we need to correct for multiple testing.
  DESeq2 uses the Benjamini-Hochberg False Discovery Rate (FDR) correction,
  and these values are reported in the column `padj` (i.e., adjusted p-value).

### `NA` values in the results table

Some values in the results table can be set to `NA` for one of the following reasons:

- If within a row, all samples have zero counts,
  the `baseMean` column will be zero, and the log2-fold change estimates,
  p-value and adjusted p-value will all be set to `NA`.

- DESeq2 performs outlier detection using Cook's distance.
  If a gene contains a sample with an count outlier,
  both the p-value and adjusted p-value will be set to `NA`.

- DESeq2 also automatically filters low mean count genes in the sense that it
  does not include them in the multiple testing correction.
  Therefore, in such cases, the p-value will not be `NA`, but the adjusted p-value
  will be.
  
  Because we have very low power to detect differential expression for such
  low-count genes, it is beneficial to remove them prior to the multiple testing
  correction, so this correction becomes less severe for the remaining genes.

Let's see how many genes have `NA` p-values:

```{r}
# Number of genes with NA p-value:
sum(is.na(results(dds)$pvalue))

# As a proportion of the total number of genes in the test:
sum(is.na(results(dds)$pvalue)) / nrow(results(dds))
```

And `NA` adjusted p-values:

```{r}
# Number of genes with NA p-value:
sum(is.na(results(dds)$padj))

# As a proportion of the total number of genes in the test:
sum(is.na(results(dds)$padj)) / nrow(results(dds))
```

<br>

----

## DE analysis -- contrast two groups

```{r, eval=FALSE}
resultsNames(dds)
```

```{r, eval=FALSE}
my_contrast <- c("Ri_Agrobacterium_myb", "Ri_Agrobacterium_noexp")
```

```{r, eval=FALSE}
res <- results(dds,
               contrast = c("group", my_contrast))
```

- How many adjusted p-values were less than 0.1?

```{r, eval=FALSE}
sum(res$padj < 0.1, na.rm = TRUE)
```

<br>

----

## Exploring the results

### MA-plot:

```{r, eval=FALSE}
plotMA(res, ylim = c(-2, 2))
```

```{r, echo=FALSE}
# May also want to do this after shrinkage
# resLFC <- lfcShrink(dds, coef="condition_treated_vs_untreated", type="apeglm")
```

### Plot specific genes:

```{r, eval=FALSE}
d <- plotCounts(dds,
                gene = which.min(res$padj),
                intgroup = "group",
                returnData = TRUE)

p <- ggplot(d, aes(x = group, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

```

### Heatmap:

```{r, eval=FALSE}
ntd <- normTransform(dds)
select <- order(rowMeans(counts(dds, normalized = TRUE)),
                decreasing = TRUE)[1:20]
ntd_sel <- assay(ntd)[select, ]
df_meta <- as.data.frame(colData(dds)[, c("AMF", "Treatment")])
```

```{r, eval=FALSE}
pheatmap(ntd_sel,
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         show_rownames = FALSE,
         annotation_col = df_meta)
```

### Export the results

TBA

<br>

----

## DE analysis -- with two factors

TBA

```{r, eval=FALSE, echo=FALSE}
design <- as.formula(~ AMF + Treatment)
ddsObj.raw <- DESeqDataSetFromMatrix(countData = counts,
                                     colData = metadata,
                                     design = design)
ddsObj <- DESeq(ddsObj.raw)
```


